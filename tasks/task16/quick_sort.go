package main

import "fmt"

/*
Реализовать быструю сортировку массива (quicksort) встроенными методами языка.
*/

func qSort(arr []int, beg, end int) {
	// завершаем функцию, если гранциы "сомкнулись"
	if end-beg <= 1 {
		return
	}

	// создаем новые переменные для границ, новые для предотвращения их перезаписи на стэке при рекурсивом вызове
	i := beg
	j := end
	q := arr[beg+(end-beg)/2] // выбираем опорный эелемент
	// запускем цикл с условием: пока индекс левой границы будет меньше индекса правого
	for i <= j {
		// еще один цикл: мы инкрементируем индекс левой границы пока текущий элемент среза < опорного
		for arr[i] < q {
			i++
		}
		// цикл: мы декрементируем индекс правой границы > опорного
		for arr[j] > q {
			j--
		}
		// если индекс левой границы <= правой, то меняем местами эелементы
		if i <= j {
			arr[i], arr[j] = arr[j], arr[i]
			i++ // увеличиваем индекс левой границы, чтобы перейти далее
			if j > 0 {
				j--
			}
		}
	}

	// если левая граница меньше опорного элемента, то рекурсивно вызываем ф-ю сортировки,
	//передавая указатель на срез, прежнюю левую границу и новую правую
	if beg < j {
		qSort(arr, beg, j)
	}
	// при данном случае наоборот
	if end > i {
		qSort(arr, i, end)
	}
}

func main() {
	arr := []int{0, 3, 2, 6, 8, 4, -4, 5, 0, 1}
	beg := 0            // индекс крайнего левого элемента
	end := len(arr) - 1 // индекс крайнего правого элемента
	qSort(arr, beg, end)
	fmt.Print(arr)
}

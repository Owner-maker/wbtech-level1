package main

import (
	"fmt"
	"sync"
)

/*
Дана последовательность чисел: 2,4,6,8,10. Найти сумму их
квадратов(2^2+3^2+4^2….) с использованием конкурентных вычислений

-----------------------------------------------------------------

Второе решение уже более безопасно: здесь я использую Mutex для того, чтобы в случае, когда одна горутина захватила значение
общего накопителя, то другая горутина ожидала освобождения Mutex первой, чтобы произвести чтение и запись. В таком случае
накопитель будет изменяться корректно.
*/

func main() {
	// создаем массив типа int[5] и заполняем значениями
	values := [5]int{2, 4, 6, 8, 10}
	sum := 0 // накопитель

	// объявляем переменную типа WaitGroup, которая позволит дождаться выполнения всех горутин
	var w sync.WaitGroup
	// объявляем переменную типа Mutex
	var m sync.Mutex

	// задаем цикл для прохождения по values
	for _, val := range values {

		// увеличиваем счетчик на 1 перед запуском очередной горутины
		w.Add(1)
		// запуск горутины (легковесный поток), принимает в качестве параметра - int
		go func(val int) {
			temp := val * val // заранее проводим вычисление, чтобы "сэкономить" время
			m.Lock()          // блокируем Mutex
			sum += temp
			m.Unlock() // освобождаем Mutex
			w.Done()   // необходимо после завершения горутины уменьшить счетчик на 1
		}(val) // сразу после объявлеия анонимной функции вызываем горутину
	}

	//вызываем метод Wait(), который позволит дождаться выполнения всех горутин благодаря счетчику
	//когда счетчик = 0 -> программа завершится
	w.Wait()
	fmt.Print(sum)
}

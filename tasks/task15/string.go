package main

import (
	"errors"
	"fmt"
	"math/rand"
)

/*
К каким негативным последствиям может привести данный фрагмент кода, и как
это исправить? Приведите корректный пример реализации.

var justString string

	func someFunc() {
		v := createHugeString(1 << 10)
		justString = v[:100]
	}

	func main() {
		someFunc()
	}

---------------------------------------------------------------------------

1) С точки зрения вызова функции createHugeString() у нас нет возможности передавать параметр для создания этой функции
это может пригодится в будущем
2) При использовании глобальной переменной может быть много сайд - эффектов, такая функция уже не являеся чистой, на мой взгляд
желательно возвращать новую строку, ее же создавать в теле функции
3) Вполне вероятно, что можем выйти за границы массива байт строки, поэтому необходимо либо в теле функции добавить условую конструкцию с
жестко фиксированным значением для проверки, либо использовать внешнюю константу, либо передавать ее в качестве параметра
- C другой стороны, если мы имеем дело с глобальной переменной как со своего рода параметром, который нужно при необходимости менять
через функции, то в таком случае это может иметь смысл, в данном случае я думаю использовать именно этот случай
4) Когда мы берем и создаем новую строку через срез -> то работаем с байтами, т.е. при обычных симолах мы не заметим разницы, но, к примеру, при
использовании кириллицы, где используется по 2 байта на символ, то тут ответ будет совершенно другим, поэтому лучше  использовать срез рун
*/

var justString string

func createHugeString(size int) *[]rune {
	baseString := []rune("ФЫВАПРОЛДЖсмитьбю") // создаем слайс рун от базовой строки (той, из которой будет состоять нужная строка)

	res := make([]rune, size) // итоговый срез

	// итеративно проходимся по итоговму срезу рун и кладем случайно выбранный элемент из базовой строки (среза рун)
	for i := range res {
		res[i] = baseString[rand.Intn(len(baseString))]
	}
	return &res
}

func someFunc(offset, neededSize, maxSize int) error {
	if neededSize > maxSize {
		return errors.New("needed size of the string can not be above the max size of generating one")
	}
	if maxSize <= 0 || neededSize <= 0 {
		return errors.New("sizes values can not be negative or equals zero")
	}
	if offset < 0 {
		return errors.New("offset can not be negative")
	}
	hugeStr := *createHugeString(maxSize)
	justString = string(hugeStr[offset:neededSize]) // присваиваем глоабльной переменной срез от мин. до необходимого значения
	return nil
}

func main() {
	if err := someFunc(10, 100, 150); err != nil {
		fmt.Print(err)
		return
	}
	fmt.Print(justString) // вывод: ФбДДАЫмВьиюбЛьюАЫПсьюВЖсПмПЛмАЫюЫьЖьюЖсПЫсюсЫибЫЫФюРиЫЫОВРсОьРЫбЫюАЫПмЫьЖЫмЫПАЫибАВтПтмДФА
}

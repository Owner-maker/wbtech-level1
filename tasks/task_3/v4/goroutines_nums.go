package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

/*
Дана последовательность чисел: 2,4,6,8,10. Найти сумму их
квадратов(2^2+3^2+4^2….) с использованием конкурентных вычислений

-----------------------------------------------------------------

Четвертое решение - с использование атомиков. Данное решение на мой взгляд и безопасное и максимльно эффективное, т.к.
атомики реализованы уже на уровне самого "железа", минуя некоторые слои абстракции, что делает их работу быстрее
*/

func main() {
	// создаем массив типа int[5] и заполняем значениями
	values := [5]int64{2, 4, 6, 8, 10}
	var sum int64 // накопитель типа int64

	// объявляем переменную типа WaitGroup, которая позволит дождаться выполнения всех горутин
	var w sync.WaitGroup

	// задаем цикл для прохождения по values
	for _, val := range values {

		// увеличиваем счетчик на 1 перед запуском очередной горутины
		w.Add(1)
		// запуск горутины (легковесный поток), принимает в качестве параметра - int
		go func(val int64) {
			// увеличиваем значение переменной sum с использованием пакеты atomic
			atomic.AddInt64(&sum, val*val)
			w.Done() // необходимо после завершения горутины уменьшить счетчик на 1
		}(val) // сразу после объявлеия анонимной функции вызываем горутину
	}

	//вызываем метод Wait(), который позволит дождаться выполнения всех горутин благодаря счетчику
	//когда счетчик = 0 -> программа завершится
	w.Wait()
	fmt.Print(sum)
}
